---
title: "Introduction to the `patientProfilesVis` package"
author: "Laure Cougnaud"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{Introduction to the patientProfilesVis package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Introduction

```{r options, echo = FALSE}
	
	library(knitr)
	opts_chunk$set(
		echo = TRUE, results = 'asis', warning = FALSE, 
		error = FALSE, message = FALSE, cache = FALSE,
		fig.width = 8, fig.height = 7,
		fig.path = "./figures_vignette/",
		#out.width = '0.7\\textwidth', 
		fig.align = 'center')#, out.height = 0.5\\textwidth', fig.path = 'graphs/') 
	options(width = 170)#, stringsAsFactors = FALSE
	options(warn = 1)#instead of warn = 0 by default -> to have place where warnings occur in the call to Sweave function
	
	heightLineIn  <- 0.2
	
```

This package `patientProfilesVis` enables to create report containing subject
profiles.

```{r loadPackages}

	library(patientProfilesVis)
	library(pander)

```

## Data format

The input dataset for the workflow should be a data.frame, 
usually loaded from a _SAS_ data file (`sas7bdat` format).
The label of the variables stored in the `SAS` datasets is also used
for title/captions. 

The function `loadDataADaMSDTM` can be used to load your custom `SAS` dataset(s) of
interest.
This function returns two objects:

* a list of `data.frame` containing the data for each _SAS_ dataset(s), stored
  in the `$data` slot
* a vector containing the labels for each column of the data (used e.g. for
  default titles of the figures), stored in the `$labelVars` slot

A few `sdtm` datasets from the _Pelican_ study are included in the
`glpgUtilityFct` package for the demonstration, via the dataset
`SDTMDataPelican` and corresponding variable labels `labelVarsSDTMPelican`.

```{r loadData}	
	
	library(glpgUtilityFct)

	# example dataset(s) formatted as a list of data.frame
	data(SDTMDataPelican)
#	pander(lapply(SDTMDataPelican, head, 1))
	
	# and corresponding labels
	data(labelVarsSDTMPelican)
#	pander(head(labelVarsSDTMPelican))
	
	# load example ADaM dataset
	data(ADaMDataPelican)
	# ... and corresponding labels
	data(labelVarsADaMPelican)
	
```

# Creation of the plot modules

Four plot types/modules are currently available in the package:

* **'text'** module: patient specific information formatted as text, available
  via the `subjectProfileTextPlot` function
* **'interval'** module: representation of time interval of a certain event,
  available via the `subjectProfileIntervalPlot` function
* **'event'** module: representation of single event, available via the
  `subjectProfileEventPlot`
* **'line'** module: representation of evolution of a value across time via the 
`subjectProfileLinePlot`
  
Each of this function returns a nested list of plots (`ggplot` object).
Each element of the list contains the plots for a specific subject.
The subject profile plot for a specific module is possibly into
multiple plots to fit in the final report (`formatReport` parameter).
  
## Text module

The 'text' module enables to specify meta-information for each subject.
There are two ways to specify such information, either by specifying a set of
variables/columns of the data (`paramValueVar` only), or by a variable/column
containing the parameter name (`paramNameVar`) and variable(s)/column(s)
containing the parameter value (`paramValueVar`).

### Wide format

```{r exampleTextModule-wideFormat}

	# annotate subject demographics meta-data
	# by specifying a set of variables to include
	dmPlots <- subjectProfileTextPlot(
		data = SDTMDataPelican$DM,
		paramValueVar = c("SEX|AGE", "RACE|COUNTRY", "ARM"),
		labelVars = labelVarsSDTMPelican
	)
	
```

```{r exampleTextModule-wideFormat-include, echo = FALSE, fig.height = attributes(dmPlots[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Demographic information with the 'subjectProfileTextPlot' function for patient:", names(dmPlots)[1])}

	print(dmPlots[[1]][[1]])

```

### Long format

#### General

It is possible to specify multiple variable to represent in the plot
for a certain variable name.

```{r exampleTextModule-longFormat-noGrouping}	

	# annotate subject medical history
	# by specifying a combination of parameter value/name
	mhPlots <- subjectProfileTextPlot(
		data = SDTMDataPelican$MH,
		paramNameVar = "MHTERM",
		paramValueVar = c("MHCAT", "MHSTDTC", "MHENDTC"),
		title = "Medical History: status",
		labelVars = labelVarsSDTMPelican
	)
		
```

```{r exampleTextModule-longFormat-noGrouping-include, echo = FALSE, fig.height = attributes(mhPlots[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Medical history with the 'subjectProfileTextPlot' function for patient:", names(mhPlots)[1])}

	print(mhPlots[[1]][[1]])

```

### Table format (listing)

Information are displayed as a table format by setting the `table` parameter to TRUE.

```{r exampleTextModule-tableFormat}

	aeListingPlots <- subjectProfileTextPlot(
		data = SDTMDataPelican$AE,
		paramValueVar = c("AEBODSYS", "AESOC", "AEHLT", "AELLT", "AEDECOD", "AESTDTC", "AEENDTC", "AESER", "AEACN"),
		paramGroupVar = "AESTDTC",
		labelVars = labelVarsSDTMPelican,
		table = TRUE
	)
	subjID <- SDTMDataPelican$AE[which.max(nchar(SDTMDataPelican$AE$AETERM)), "USUBJID"]
	
```

```{r exampleTextModule-tableFormat-include, echo = FALSE, fig.height = attributes(aeListingPlots[[subjID]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Adverse event listing with the 'subjectProfileTextPlot' function for patient:", subjID)}

	print(aeListingPlots[[subjID]][[1]])

```

By default, the widths of the columns of the table are optimized based on the column content, 
but custom widths can be specified via the `colWidth` parameter.

```{r exampleTextModule-tableFormat-customWidth}

	aeListingPlots <- subjectProfileTextPlot(
		data = SDTMDataPelican$AE,
		paramValueVar = c("AEBODSYS", "AESOC", "AEHLT", "AELLT", "AEDECOD", "AESTDTC", "AEENDTC", "AESER", "AEACN"),
		paramGroupVar = "AESTDTC",
		labelVars = labelVarsSDTMPelican,
		table = TRUE,
		colWidth = c(0.1, 0.1, 0.1, 0.1, 0.3, 0.05, 0.05, 0.1, 0.1)
	)
	
```

```{r exampleTextModule-tableFormat-customWidth-include, echo = FALSE, fig.height = attributes(aeListingPlots[[subjID]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Adverse event listing with the 'subjectProfileTextPlot' function for patient:", subjID)}

	print(aeListingPlots[[subjID]][[1]])

```



#### Customization for multiple variables

In case multiple variable are used as `paramValueVar` and
they should be concatenated with a specific format, a function
 can be specified via the parameter: `paramValueVar`.

```{r exampleTextModule-longFormat-multipleVariables}	

	# annotate subject medical history
	# by specifying a combination of parameter value/name
	paramValueVarFct <- function(data)
		with(data, paste0(MHENRTPT, " (start = ", MHSTDTC, 
			ifelse(MHENDTC != "", paste0(", end = ", MHENDTC, ")"), ")")
			)
		)
	mhPlotsMultipleVars <- subjectProfileTextPlot(
		data = SDTMDataPelican$MH,
		paramNameVar = "MHDECOD",
		paramValueVar = paramValueVarFct,
		title = "Medical History: status with dates",
		labelVars = labelVarsSDTMPelican
	)
		
```

```{r exampleTextModule-longFormat-multipleVariables-include, echo = FALSE, fig.height = attributes(mhPlotsMultipleVars[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Medical history with the 'subjectProfileTextPlot' function for patient:", names(mhPlotsMultipleVars)[1])}

	print(mhPlotsMultipleVars[[1]][[1]])

```

#### With grouping

```{r exampleTextModule-longFormat-grouping}	

	# annotate subject medical history
	# by specifying a combination of parameter value/name
	mhPlotsGroup <- subjectProfileTextPlot(
		data = SDTMDataPelican$MH,
		paramNameVar = "MHDECOD",
		paramValueVar = "MHENRTPT",
		paramGroupVar = "MHCAT",
		title = "Medical History: grouped by category",
		labelVars = labelVarsSDTMPelican
	)
	
```

```{r exampleTextModule-longFormat-grouping-include, echo = FALSE, fig.height = attributes(mhPlotsGroup[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Medical history with the 'subjectProfileTextPlot' function for patient:", names(mhPlotsGroup)[1])}

	print(mhPlotsGroup[[1]][[1]])

```

## Interval/Range module

The 'interval' module enables to represent a time interval for
some parameters/events of interest.

### Adverse events

It is used here to represent the start/end date of the adverse events.

Please **check section [Missing starting/end time](#intervalMissingStartEnd) for further information 
on how records with
missing start/end date are represented**.

```{r exampleIntervalModule-ae}

	# AEPTCD: preferred term code
	dataAE <- SDTMDataPelican$AE
	# specify order of value in 'AESEV'
	dataAE[, "AESEV"] <- factor(dataAE[, "AESEV"], levels = c("MILD", "MODERATE"))
	aePlots <- subjectProfileIntervalPlot(
		data = dataAE,
		paramVar = "AETERM",
		timeStartVar = "AESTDY",
		timeEndVar = "AEENDY",
		colorVar = "AESEV",
		labelVars = labelVarsSDTMPelican,
		title = "Adverse events"
	)
	subjectAE <- "study-4907-07"
		
```

```{r exampleIntervalModule-ae-include, echo = FALSE, fig.height = attributes(aePlots[[subjectAE]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Adverse events with the 'subjectProfileIntervalPlot' function for patient:", subjectAE)}

	print(aePlots[[subjectAE]][[1]])

```

### Exposure

The exposure of the patients to certain treatment(s) is also represented in
this time interval visualization

```{r exampleIntervalModule-ex}

	# AEPTCD: preferred term codes
	exPlots <- subjectProfileIntervalPlot(
		data = SDTMDataPelican$EX,
		paramVar = c("EXTRT", "EXDOSE", "EXDOSU"),
		timeStartVar = "EXSTDY",
		timeEndVar = "EXENDY",
		colorVar = "EXDOSFRM",
		labelVars = labelVarsSDTMPelican,
		title = "Treatment exposure"
	)

```

```{r exampleIntervalModule-exinclude, echo = FALSE, fig.height = attributes(exPlots[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Exposure interval with the 'subjectProfileIntervalPlot' function for patient:", names(exPlots)[1])}

	print(exPlots[[1]][[1]])

```

### Concomitant medications

```{r exampleIntervalModule-cm}

	# AEPTCD: preferred term codes
	cmPlots <- subjectProfileIntervalPlot(
		data = SDTMDataPelican$CM,
		paramVar = c("CMINDC", "CMTRT", "CMDOSTXT", "CMDOSU", "CMROUTE", "CMDOSFRQ"),
		timeStartVar = "CMSTDY",
		timeEndVar = "CMENDY",
		paramGroupVar = "CMINDC",
		colorVar = "CMINDC",
		labelVars = labelVarsSDTMPelican,
		title = "Concomitant medications"
	)
	subjectCM <- "study-4905-02"

```

```{r exampleIntervalModule-cm-include, echo = FALSE, fig.height = attributes(cmPlots[[subjectCM]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Concomitant medications with the 'subjectProfileIntervalPlot' function for patient:", subjectCM)}

	print(cmPlots[[subjectCM]][[1]])

```

### Missing starting/end time {#intervalMissingStartEnd}

The interval visualization requires specified start/end time for each record.
However, records with missing starting/end time are frequently collected.
Different types of missing values can occur during a clinical study:

* partial dates, e.g. concomitant medication in 2012, relative date not encoded
* on-going event at data collection, e.g. adverse event
* 'true' missing: actual date not reported

It might be important to still display these records in the visualization, so
different types of imputation for missing start/end date for the
interval visualization are available in the package.

Please **have a look at the section 'Details' of the documentation of 
the `subjectProfileIntervalPlot` function for the 
most up-to-date information on this imputation**.

#### Default imputation

By default, **minimal imputation** is used (specified via the parameter `timeImpType`).
Specific symbols are used to represent missing starting/end time.

Records with:

* missing start and end times are only displayed with their labels in the y-axis
* missing start only: record are displayed at the specified end with an left-directed arrow
* missing end only: record are displayed at the specified start with an right-directed arrow

```{r exampleIntervalModule-ae-default, message = TRUE}

	# AEPTCD: preferred term code
	dataAE <- SDTMDataPelican$AE
	# specify order of value in 'AESEV'
	dataAE[, "AESEV"] <- factor(dataAE[, "AESEV"], levels = c("MILD", "MODERATE"))
	aePlots <- subjectProfileIntervalPlot(
		data = dataAE,
		paramVar = "AETERM",
		timeStartVar = "AESTDY",
		timeEndVar = "AEENDY",
		colorVar = "AESEV",
		labelVars = labelVarsSDTMPelican,
		title = "Adverse events"
	)
		
```

```{r exampleIntervalModule-ae-default-include, echo = FALSE, fig.height = attributes(aePlots[[subjectAE]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Adverse events with the 'subjectProfileIntervalPlot' function for patient:", subjectAE)}

	print(aePlots[[subjectAE]][[1]])

```

#### Imputation based on an external dataset

To set the values represented for records with missing start/end dates, 
the **time limits can be extracted** from a 
**specified dataset containing the start/end date for each subject** via 
the **`timeLimData`/`timeLimStartVar`/`timeLimEndVar`** parameters.

This option is used below to impute missing starting/end time with the first/last visit
for each subject based on the 'Subject Visit' dataset.

```{r exampleIntervalModule-ae-timeLimData, message = TRUE}

	aePlotsTimLimFromSV <- subjectProfileIntervalPlot(
		data = dataAE,
		paramVar = "AETERM",
		timeStartVar = "AESTDY",
		timeEndVar = "AEENDY",
		colorVar = "AESEV",
		labelVars = labelVarsSDTMPelican,
		title = "Adverse events",
		timeLimData = SDTMDataPelican$SV,
		timeLimStartVar = "SVSTDY", 
		timeLimEndVar = "SVENDY"
	)
	
```

```{r exampleIntervalModule-ae-timeLimData-include, echo = FALSE, fig.height = attributes(aePlotsTimLimFromSV[[subjectAE]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste0("Adverse events with the 'subjectProfileIntervalPlot' function for patient:", subjectAE, ". Missing start/end date are extracted from the subject-level dataset.")}

	print(aePlotsTimLimFromSV[[subjectAE]][[1]])

```

```{r exampleIntervalModule-ae-timeLimData-svData}
	svSubjectAE <- subset(SDTMDataPelican$SV, USUBJID == "study-4907-07")[, c("VISIT", "SVSTDY", "SVENDY")]
	pander(svSubjectAE)
```

This is also used to restrict the time limits of the plots.
The time limits of the concomitant medications is quite large compared to the
study time range.
As the modules will be combined with the same time limits, it might be
advisable to restrict the time limits for this module via the `timeLimData`,
`timeLimStartVar` and `timeLimEndVar` parameter.
In this example the time limits are restricted to the minimum/maximum
time range of the subject visits.

```{r exampleIntervalModule-cm-restrictedTimeLimits}

	cmPlotsTimeSV <- subjectProfileIntervalPlot(
		data = SDTMDataPelican$CM,
		paramVar = c("CMINDC", "CMTRT", "CMDOSTXT", "CMDOSU", "CMROUTE", "CMDOSFRQ"),
		timeStartVar = "CMSTDY",
		timeEndVar = "CMENDY",
		paramGroupVar = "CMINDC",
		colorVar = "CMINDC",
		labelVars = labelVarsSDTMPelican,
		title = "Concomitant medications",
		timeLimData = SDTMDataPelican$SV,
		timeLimStartVar = "SVSTDY",
		timeLimEndVar = "SVENDY"
	)

```

```{r exampleIntervalModule-cm-restrictedTimeLimits-include, echo = FALSE, fig.height = attributes(cmPlotsTimeSV[[subjectCM]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Concomitant medications with the 'subjectProfileIntervalPlot' function for patient:", subjectCM, "with time limits restricted to subject visits")}

	print(cmPlotsTimeSV[[subjectCM]][[1]])

```

#### Custom specification for missing and partial dates

Missing start/end dates, partial dates or custom date status can be specified
by creating two extra variables in the input data containing the status of the
start/end time (`timeStartShapeVar`/`timeEndShapeVar`). 
This status is represented as different symbols in the plot.
In this case the `timeStartVar`/`timeEndVar` variables already contain the imputed
date in case of missing values.

Please note that because the [default `ggplot2` symbol palette](https://ggplot2.tidyverse.org/reference/scale_shape.html)
doesn't contain the left and right triangle symbols; these are specified
in Unicode format in hexadecimal (see [List of unicode symbols](https://en.wikipedia.org/wiki/List_of_Unicode_characters)).

```{r exampleIntervalModule-ae-customMissingPartialDates}

	# add status for dates:
	dataAE$AESTDYST <- with(dataAE, 
		ifelse(is.na(AESTDY) & !is.na(AESTDY), "Missing start", "")
	)
	
	shapePalette <- c(
		`Missing start`= "\u25C4", # left-pointing arrow
		'NOT RECOVERED/NOT RESOLVED' = "\u25BA", # right-pointing arrow
		'RECOVERED/RESOLVED' = "\u25A0", # small square
		UNKNOWN = "+"
	)
	
	aePlotsShape <- subjectProfileIntervalPlot(
		data = dataAE,
		paramVar = "AETERM",
		timeStartVar = "AESTDY", timeEndVar = "AEENDY",
		timeStartShapeVar = "AESTDYST", timeEndShapeVar = "AEOUT",
		shapePalette = shapePalette,
		shapeLab = "Study date status", 
		colorVar = "AESEV",
		labelVars = labelVarsSDTMPelican,
		title = "Adverse events"
	)

```

```{r exampleIntervalModule-ae-customMissingPartialDates-include, echo = FALSE, fig.height = attributes(aePlotsShape[["study-4904-01"]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Adverse events with the 'subjectProfileIntervalPlot' function for patient:", subjectAE, "with custom shape specification")}

	print(aePlotsShape[["study-4904-01"]][[1]])

```

### Specification of time limits

To restrict the time range in the visualization, the time limits can be set via the `timeLim` parameter:

```{r exampleIntervalModule-cm-restrictedTimeLimits2}

	timeLim <- c(-28, 53)
	cmPlotsTimeSpec <- subjectProfileIntervalPlot(
		data = SDTMDataPelican$CM,
		paramVar = c("CMINDC", "CMTRT", "CMDOSTXT", "CMDOSU", "CMROUTE", "CMDOSFRQ"),
		timeStartVar = "CMSTDY",
		timeEndVar = "CMENDY",
		paramGroupVar = "CMINDC",
		colorVar = "CMINDC",
		labelVars = labelVarsSDTMPelican,
		title = "Concomitant medications",
		timeLim = timeLim
	)

```

```{r exampleIntervalModule-cm-restrictedTimeLimits2-include, echo = FALSE, fig.height = attributes(cmPlotsTimeSpec[[subjectCM]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Concomitant medications with the 'subjectProfileIntervalPlot' function for patient:", subjectCM, "with time limits restricted to: (", toString(timeLim), ")")}

	print(cmPlotsTimeSpec[[subjectCM]][[1]])

```

### Non-alignment across subjects {#subjectIntervalTimeAlign}

By default, the visualizations created with the `subjectProfileIntervalPlot`
are aligned in the time-axis across subjects.

To obtain visualization which don't align, the parameter: `timeAlign` is set to FALSE.

```{r exampleIntervalModule-cm-timeAlign-FALSE}

	cmPlotsNotAligned <- subjectProfileIntervalPlot(
		data = SDTMDataPelican$CM,
		paramVar = c("CMINDC", "CMTRT", "CMDOSTXT", "CMDOSU", "CMROUTE", "CMDOSFRQ"),
		timeStartVar = "CMSTDY",
		timeEndVar = "CMENDY",
		paramGroupVar = "CMINDC",
		colorVar = "CMINDC",
		labelVars = labelVarsSDTMPelican,
		title = "Concomitant medications",
		timeAlign = FALSE
	)

```

In this case, each visualization contains specific time-limits.

```{r exampleIntervalModule-cm-timeAlign-FALSE-include-1, echo = FALSE, fig.height = attributes(cmPlotsNotAligned[[subjectCM]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Adverse events with the 'subjectProfileIntervalPlot' function for patient:", subjectCM, "with custom shape specification")}

	print(cmPlotsNotAligned[[subjectCM]][[1]])

```

When building the report, the same parameter should be used 
(see section [Report creation](#createSubjectProfileReportTimeAlign)).

## Event module

### General

The 'event' module enables to represent event data.

This is used to represent the presence/absence of a certain
laboratory measurement (and corresponding time).

```{r exampleEventModule}
	
	## laboratory data
	
	# prepare data for plots:
	dataLB <- SDTMDataPelican$LB
	# sort the categories (empty values '' becomes NA)
	dataLB$LBNRIND <- factor(dataLB$LBNRIND, levels = c("LOW", "NORMAL", "HIGH"))
	
	# create plot
	lbPlots <- subjectProfileEventPlot(
		data = dataLB,
		paramVar = c("LBSCAT", "LBTEST"),
		paramGroupVar = "LBSCAT",
		timeVar = "LBDY",
		labelVars = labelVarsSDTMPelican,
		title = "Laboratory test measurements"
	)

```

```{r exampleEventModule-include, echo = FALSE, fig.height = attributes(lbPlots[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Laboratory data with the 'subjectProfileEventPlot' function for patient:", names(lbPlots)[1])}

	print(lbPlots[[1]][[1]])

```

### Color variable

The reference range indicator is used to color the presence/absence of the
laboratory data via the `colorVar` parameter.
This parameter is also used for the symbol via the `shapeVar` variable.
Symbols specific of this categorization are used via the `shapePalette`
parameter: bottom/top arrow for low/high measurements, and dot for measurements
in normal range.

```{r exampleEventModuleWithColor}

	# create plot
	lbPlotsColor <- subjectProfileEventPlot(
		data = dataLB,
		paramVar = "LBTEST",
		paramGroupVar = "LBSCAT",
		timeVar = "LBDY",
		colorVar = "LBNRIND",
		labelVars = labelVarsSDTMPelican,
		shapeVar = "LBNRIND",
		shapePalette = c('LOW' = 25, 'NORMAL' = 19, 'HIGH' = 24, 'NA' = 3),
		title = "Laboratory test measurements: reference range indicator"
	)
	
```

```{r exampleEventModuleWithColor-include, echo = FALSE, fig.height = attributes(lbPlotsColor[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Laboratory data with reference range with the 'subjectProfileEventPlot' function for patient:", names(lbPlotsColor)[1])}

	print(lbPlotsColor[[1]][[1]])

```

### Subset of interest

A subset of interest can be specified via:

* a dataset of interest
* a variable/values of interest (possibly from a different dataset in hand)
* a set of subjects of interest

These parameters are also available for all other module types.

#### Subset based on extra variable

If only a subset of parameters are of interest `subsetVar` and
`subsetValue` can be used. 
By default, the subset is extracted from the current `data`, but can also be extracted from a
different dataset specified via `subsetData`.
These parameters are here used to represent only the measurements for the
hematology parameters.

```{r exampleEventModuleWithSubset}

	# create plot
	lbPlotsSubset <- subjectProfileEventPlot(
		data = dataLB,
		paramVar = "LBTEST",
		subsetVar = "LBCAT", subsetValue = "HEMATOLOGY",
		timeVar = "LBDY",
		colorVar = "LBNRIND",
		labelVars = labelVarsSDTMPelican,
		shapeVar = "LBNRIND",
		shapePalette = c('LOW' = 25, 'NORMAL' = 19, 'HIGH' = 24, 'NA' = 3),
		title = "Hematology test measurements"
	)
	cat("The", length(lbPlotsSubset), "patients with hematology measurements:", toString(names(lbPlotsSubset)), "are considered.\n")
	
```

```{r exampleEventModuleWithSubset-include, echo = FALSE, fig.height = attributes(lbPlotsSubset[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Hematology data with the 'subjectProfileEventPlot' function for patient:", names(lbPlotsSubset)[1])}

	print(lbPlotsSubset[[1]][[1]])

```

#### Set of subjects of interest

A set of subjects of interest from the input `data` can be specified via the `subjectSubset` parameter (by default
extracted from the `subjectVar` parameter):

```{r exampleEventModuleWithSubset-2}

	# create plot
	lbPlotsSubjectSubset <- subjectProfileEventPlot(
		data = dataLB,
		paramVar = "LBTEST",
		subsetVar = "LBCAT", subsetValue = "HEMATOLOGY",
		subjectSubset = names(lbPlotsSubset)[1],
		timeVar = "LBDY",
		colorVar = "LBNRIND",
		labelVars = labelVarsSDTMPelican,
		shapeVar = "LBNRIND",
		shapePalette = c('LOW' = 25, 'NORMAL' = 19, 'HIGH' = 24, 'NA' = 3),
		title = "Laboratory test measurements for subject of interest"
	)
	cat("Only the patient:", toString(names(lbPlotsSubjectSubset)), "is considered.\n")
	
```

```{r exampleEventModuleWithSubset-2-include, echo = FALSE, fig.height = attributes(lbPlotsSubjectSubset[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Hematology data with the 'subjectProfileEventPlot' function for patient:", names(lbPlotsSubset)[1])}

	print(lbPlotsSubjectSubset[[1]][[1]])
	
```

#### Subset based on a different dataset

The `subsetData` parameter is used to specify only a subset of the subjects 
available in a different dataset.
For example, to create the laboratory plots only for the patients with adverse events:

```{r exampleEventModuleWithSubset-3}

	# create plot
	lbPlotsDataSubset <- subjectProfileEventPlot(
		data = dataLB,
		paramVar = "LBTEST",
		subsetData = SDTMDataPelican$AE,
		timeVar = "LBDY",
		colorVar = "LBNRIND",
		labelVars = labelVarsSDTMPelican,
		shapeVar = "LBNRIND",
		shapePalette = c('LOW' = 25, 'NORMAL' = 19, 'HIGH' = 24, 'NA' = 3),
		title = "Laboratory test measurements for patients with adverse events"
	)
	cat("Only the", length(lbPlotsDataSubset), "subjects in the AE dataset are considered.")
	
```

```{r exampleEventModuleWithSubset-3-include, echo = FALSE, fig.height = attributes(lbPlotsDataSubset[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Hematology data with the 'subjectProfileEventPlot' function for patient:", names(lbPlotsSubset)[1])}

	print(lbPlotsDataSubset[[1]][[1]])
	
```

## Line module

### General

The 'line' module enables to represent value of a variable across time.

This is used to represent the evolution of the lab parameters.

The reference range (`paramValueRangeVar` variable) of each variable is
highlighted in the plot.

```{r exampleLineModule}

	# create plot
	lbLinePlots <- subjectProfileLinePlot(
		data = dataLB,
		paramNameVar = "LBTEST", 
		paramValueVar = "LBSTRESN",
		paramGroupVar = "LBSCAT",
		paramValueRangeVar = c("LBSTNRLO", "LBSTNRHI"),
		timeVar = "LBDY",
		title = "Laboratory test measurements: actual value",
		labelVars = labelVarsSDTMPelican
	)
	
```

```{r exampleLineModule-include, echo = FALSE, fig.height = attributes(lbLinePlots[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Laboratory data with the 'subjectProfileLinePlot' function for patient:", names(lbLinePlots)[1])}

	print(lbLinePlots[[1]][[1]])

```

### Color/symbols of each observation

The color and the shape of the points can be specified via the 
`colorVar` and `shapeVar` parameters, similarly as for
the `subjectProfileEventPlot` function.
The reference range measurement is represented via these parameters.

```{r exampleLineModule-colorShape}

	# create plot
	lbLinePlotsColorShape <- subjectProfileLinePlot(
		data = dataLB,
		paramNameVar = "LBTEST", 
		paramValueVar = "LBSTRESN",
		colorVar = "LBNRIND",
		shapeVar = "LBNRIND",
		shapePalette = c('LOW' = 25, 'NORMAL' = 19, 'HIGH' = 24),
		paramGroupVar = "LBSCAT",
		paramValueRangeVar = c("LBSTNRLO", "LBSTNRHI"),
		timeVar = "LBDY",
		title = "Laboratory test measurements: actual value",
		labelVars = labelVarsSDTMPelican
	)
	
```

```{r exampleLineModule-colorShape-include, echo = FALSE, fig.height = attributes(lbLinePlotsColorShape[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Laboratory data with reference range with the 'subjectProfileLinePlot' function for patient:", names(lbLinePlotsColorShape)[1])}

	print(lbLinePlotsColorShape[[1]][[1]])

```

### Reference range

#### Display reference range indicators

A reference range can be visualized if two variables
containing the low and upper limit of the range are specified
via `paramValueRangeVar`:

```{r exampleLineModule-paramValueRangeVar}

	# create plot
	lbLineRefRangePlots <- subjectProfileLinePlot(
		data = dataLB,
		paramNameVar = "LBTEST", 
		paramValueVar = "LBSTRESN",
		paramGroupVar = "LBSCAT",
		paramValueRangeVar = c("LBSTNRLO", "LBSTNRHI"),
		timeVar = "LBDY",
		title = "Laboratory test measurements: actual value",
		labelVars = labelVarsSDTMPelican
	)
	
```

```{r exampleLineModule-paramValueRangeVar-value-include, echo = FALSE, fig.height = attributes(lbLineRefRangePlots[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Laboratory data with the 'subjectProfileLinePlot' function with a reference range for patient:", names(lbLineRefRangePlots)[1])}

	print(lbLineRefRangePlots[[1]][[1]])

```

#### Range of the y-axis based on the observations or the reference range

By default, for each parameter, the range of the y-axis 
is extended to the reference range in case the 
range of the associated observations is smaller 
than the specified reference range.

If the range of the y-axis should only contain the data range, 
so shouldn't be extended
to cover the reference range, the `yLimFrom` parameter should be set on:
'value'.

```{r exampleLineModule-yLimFrom-value}

	# create plot
	lbLineYLimFromValuePlots <- subjectProfileLinePlot(
		data = dataLB,
		paramNameVar = "LBTEST", 
		paramValueVar = "LBSTRESN",
		paramGroupVar = "LBSCAT",
		paramValueRangeVar = c("LBSTNRLO", "LBSTNRHI"),
		yLimFrom = "value",
		timeVar = "LBDY",
		title = "Laboratory test measurements: actual value",
		labelVars = labelVarsSDTMPelican
	)
	
```

```{r exampleLineModule-yLimFrom-value-include, echo = FALSE, fig.height = attributes(lbLineYLimFromValuePlots[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Laboratory data with the 'subjectProfileLinePlot' function for patient:", names(lbLineYLimFromValuePlots)[1])}

	print(lbLineYLimFromValuePlots[[1]][[1]])

```

# Specification of the color/shape variables

## Missing values 

The missing values are always represented in the legend: color/shape palettes.

If the variable is specified as character (by default when the dataset is loaded
into R), the **variable is converted to a factor and empty
values ('', if any) in the variable are converted to missing (NA)**.

If the variable is specified as factor, the missing values are included in the
levels of the factor (`exclude = NULL`  in `factor`).

## Order of the categories

By **default**, if a character vector is specified, the categories are sorted in
**alphabetical order** when the variable is converted to a factor in R.

```{r lab-SDTM-categories-default, fig.height = attributes(lbPlotsColor[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14}

	## SDTM dataset

	sdtmLB <- SDTMDataPelican$LB
			
	# LBRIND is a character: elements sorted in alphabetical order
	lbPlotsColor <- subjectProfileEventPlot(
		data = sdtmLB,
		paramVar = "LBTEST",
			paramGroupVar = "LBSCAT",
		timeVar = "LBDY",
		colorVar = "LBNRIND",
		labelVars = labelVarsSDTMPelican,
		title = "Laboratory test measurements: reference range indicator"
	)
	print(lbPlotsColor[[1]][[1]])
	
```	

To **specify the elements of the variable in a specific order** (e.g. ordered
categories), the variable should be converted to a **factor with its levels
sorted in the order of interest**. 

For example, the reference ranges for the laboratory measurements are sorted
from low to high in the legend: 

```{r lab-SDTM-categories-sorted, fig.height = attributes(lbPlotsColor[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14}
	
	# sort LBRIND
	sdtmLB$LBNRIND <- with(sdtmLB, factor(LBNRIND, levels = c("LOW", "NORMAL", "HIGH")))
	lbPlotsColor <- subjectProfileEventPlot(
		data = sdtmLB,
		paramVar = "LBTEST",
		paramGroupVar = "LBSCAT",
		timeVar = "LBDY",
		colorVar = "LBNRIND",
		labelVars = labelVarsSDTMPelican,
		title = "Laboratory test measurements: reference range indicator"
	)
	print(lbPlotsColor[[1]][[1]])
	
```

In the `ADaM` dataset, for some specific variables with categories, the
corresponding numeric variable can be used for sorting:

```{r lab-ADaM-categories-sorted, fig.height = attributes(lbPlotsColor[[1]][[1]])$metaData$nLines*heightLineIn, fig.width = 14}	
	
	## ADaM
	
	# in ADaM, the reference range can be sorted based on the corresponding numeric variable
	ADLB <- ADaMDataPelican$ADLB
	ADLB$ANRIND <- with(ADLB, reorder(ANRIND, ANRINDN))
	lbPlotsColor <- subjectProfileEventPlot(
		data = ADLB,
		paramVar = "PARAM",
		paramGroupVar = "PARCAT1",
		timeVar = "ADY",
		colorVar = "ANRIND",
		labelVars = labelVarsADaMPelican,
		title = "Laboratory test measurements: reference range indicator"
	)
	print(lbPlotsColor[[1]][[1]])

```

# Time transformation

For certain module, it might be of interest to transform the time axis to e.g.
'zoom' in one part of the the study timeframe.
The `timeTrans` parameter is used to specify a custom transformation of the time-axis.

The `getTimeTrans` provides convenient transformations: 

* 'asinh': hyperbolic arc-sine transformation, to zoom in small absolute time values (around 0).
Negative and positive values are represented in a log-like fashion.
* 'asinh-neg': hyperbolic arc-sine transformation only for
negative relative time. The positive time frame is represented in a linear scale
and negative times are represented in a log-like fashion.
This is typically of interest for domains including events occurring/recorded
long before the start of the study (e.g. concomitant medications).

```{r exampleIntervalModule-cm-timeTransformation}

	timeTrans <- getTimeTrans("asinh-neg")

	# AEPTCD: preferred term codes
	cmPlots <- subjectProfileIntervalPlot(
		data = SDTMDataPelican$CM,
		paramVar = c("CMINDC", "CMTRT", "CMDOSTXT", "CMDOSU", "CMROUTE", "CMDOSFRQ"),
		timeStartVar = "CMSTDY",
		timeEndVar = "CMENDY",
		paramGroupVar = "CMINDC",
		colorVar = "CMINDC",
		labelVars = labelVarsSDTMPelican,
		title = "Concomitant medications",
		timeTrans = timeTrans
	)

```

```{r exampleIntervalModule-cm-timeTransformation-include, echo = FALSE, fig.height = attributes(cmPlots[["study-4905-02"]][[1]])$metaData$nLines*heightLineIn, fig.width = 14, fig.cap = paste("Concomitant medications with the 'subjectProfileIntervalPlot' function for patient:", names(cmPlots)[1])}

	print(cmPlots[["study-4905-02"]][[1]])

```

# Creation of subject report

The function `createSubjectProfileReport` has mainly two purposes:

* combining the plots of each patient across modules (via the
  `subjectProfileCombine` function)
* creating a _pdf_ report containing the resulting plots (one page per subject)

## Reference lines

### Reference lines for Statistical Analysis Plan

As the creation of the report is time-consuming, the report creation
is not run during the vignette creation.

```{r createReportWithAllModules-referenceLinesFromSAP, eval = FALSE}

	# reference lines input parameter
	refLinesParam <- list(
		list(
			label = 'Start screening',
			time = -28,
			color = "purple"
		), 
		list(
			label = 'End screening',
			time = -1,
			color = "purple"
		), 
		list(
			label = 'Start treatment',
			time = 1,
			color = "darkblue"
		), 
		list(
			label = 'End treatment',
			time = 29,
			color = "darkblue"
		),
		list(
			label = 'Follow-up',
			time = 49,
			color = "pink"
		)
	)

	# create report
	system.time(createSubjectProfileReport(
		listPlots = list(
			dmPlots, 
			mhPlots, 
			cmPlotsTimeSV, 
			exPlots, 
			aePlots, 
			lbLinePlots, 
			lbPlotsColor
		),
#		refLines = refLinesParam,
		timeLim = c(-20, 52),
		outputFile = "subjectProfile_SDTM_referenceLinesFromSAP.pdf",
		exportFigures = TRUE,
		verbose = TRUE,
		nCores = parallel::detectCores()
	)) # 14 mins

```

### Reference lines from subject visits

In the following example: the reference lines are extracted from the subject
visits: `SV` dataset. Bookmarks are used to reference the sex and arm for each
subject.

As the creation of the report is time-consuming, the report creation is not run during the vignette creation.

```{r createReportWithAllModules-referenceLinesFromSV, eval = FALSE}

	# create report
	createSubjectProfileReport(
		# general
		listPlots = list(dmPlots, mhPlots, exPlots, aePlots, lbPlotsColor),
		outputFile = "subjectProfile_SDTM_referenceLinesFromSV.pdf",
		# reference line(s)
		refLinesData = SDTMDataPelican$SV,
		refLinesTimeVar = "SVSTDY",
		refLinesLabelVar = "VISIT",
		# bookmark(s)
		bookmarkData = SDTMDataPelican$DM,
		bookmarkVar = c("SEX", "ARM"),
		labelVars = attr(SDTMDataPelican, "labelVars"),
		exportFigures = TRUE
	)

```

## Time non-alignment across domains {#createSubjectProfileReportTimeAlign}

To not align the different visualizations in the x-axis, e.g.
when combining a visualization displaying concomitant medications
with historical data with a high time range and 
visualization of events occuring only during the study 
timeframe; or for modules with different time units:
the modules to be aligned can be specified to the `timeAlign`
parameter.

Please note that the corresponding interval module(s)
should also be created with the parameter: `timeAlign = FALSE`
in the function `subjectProfileIntervalPlot` call 
(see section [Interval module](#subjectIntervalTimeAlign)).

Please find an example below of subject profiles displaying 
the adverse events occurring from baseline associated with
the laboratory measurements before and after baseline.

```{r createReportWithAllModules-example}

	# Adverse events visualization
	dataAE <- SDTMDataPelican$AE
	aePlots <- subjectProfileIntervalPlot(
		data = dataAE,
		paramVar = "AETERM",
		timeStartVar = "AESTDY",
		timeEndVar = "AEENDY",
		colorVar = "AESEV",
		labelVars = labelVarsSDTMPelican,
		title = "Adverse events"
	)

	# Laboratory measurements
	dataLB <- SDTMDataPelican$LB
	# sort the categories (empty values '' becomes NA)
	dataLB$LBNRIND <- factor(dataLB$LBNRIND, levels = c("LOW", "NORMAL", "HIGH"))
	lbLinePlots <- subjectProfileLinePlot(
		data = dataLB,
		paramNameVar = "LBTEST", 
		paramValueVar = "LBSTRESN",
		paramGroupVar = "LBSCAT",
		paramValueRangeVar = c("LBSTNRLO", "LBSTNRHI"),
		timeVar = "LBDY",
		title = "Laboratory test measurements: actual value",
		labelVars = labelVarsSDTMPelican
	)

	# create the list of visualizations
	# The list is named in order that the names are used
	# to reference the module for the alignment parameters
	lPlots <- list(AE = aePlots, LB = lbLinePlots)
	subsetPatients <- Reduce(intersect, lapply(lPlots, names))[1:2]

```

### Visualizations aligned across domains and subjects

By default, the visualizations are aligned across domains (`timeAlign` is 'all') 
and subjects (`timeAlignPerSubject`  is "none").

Please note that because all domains are aligned, the adverse event domain
is extended to also contain the times for laboratory measurements
(and not only from baseline on as specified during the creation of the AE visualizations). 

```{r createReportWithAllModules-default, out.width = "100%", out.height = "700px"}

	pathReport <- "subjectProfile_timeAlign-all_timeAlignPerSubject-none.pdf"
	createSubjectProfileReport(
		listPlots = lPlots,
		outputFile = pathReport,
		subset = subsetPatients
	)
	include_graphics(pathReport)
	
```

### Visualizations aligned across subjects only for a specific domain

The visualizations are aligned only for the adverse events domain 
(`timeAlign` set to: 'AE') and across subjects (`timeAlignPerSubject`  is "none").

```{r createReportWithAllModules-timeAlign-AE, out.width = "100%", out.height = "700px"}

	pathReport <- "subjectProfile_timeAlign-AE_timeAlignPerSubject-none.pdf"
	createSubjectProfileReport(
		listPlots = lPlots,
		outputFile = pathReport,
		subset = subsetPatients,
		timeAlign = "AE"
	)
	include_graphics(pathReport)
	
```

### Visualizations not aligned across domains

The visualizations are not aligned across domain (`timeAlign` set to: 'none') neither subjects (`timeAlignPerSubject`  is "none").

```{r createReportWithAllModules-timeAlign-none, out.width = "100%", out.height = "700px"}

	pathReport <- "subjectProfile_timeAlign-none_timeAlignPerSubject-none.pdf"
	createSubjectProfileReport(
		listPlots = lPlots,
		outputFile = pathReport,
		subset = subsetPatients,
		timeAlign = "none"
	)
	include_graphics(pathReport)
	
```

### Visualizations aligned per subject

The visualizations are aligned (`timeAlign` set to: 'all') per subject (`timeAlignPerSubject`  is "all").

```{r createReportWithAllModules-timeAlignPerSubject-all, out.width = "100%", out.height = "700px"}

	pathReport <- "subjectProfile_timeAlign-all_timeAlignPerSubject-all.pdf"
	createSubjectProfileReport(
		listPlots = lPlots,
		outputFile = pathReport,
		subset = subsetPatients,
		timeAlignPerSubject = "all"
	)
	include_graphics(pathReport)
	
```

## Example with the 'ADaM' dataset/format

ADaM dataset can also be used in the same framework.

As the creation of the report is time-consuming, the report creation is not run during the vignette creation.

```{r createReportFromADAMDataset, eval = FALSE}

	# subject information
	slPlotsADaM <- subjectProfileTextPlot(
		ADaMDataPelican$ADSL,
		paramValueVar = c("SEX|AGE", "RACE|COUNTRY", "ARM"),
		labelVars = labelVarsADaMPelican
	)
	# medical history
	mhPlotsADaM <- subjectProfileTextPlot(
		ADaMDataPelican$ADMH,
		paramNameVar = "MHDECOD",
		paramValueVar = "MHENRTPT",
		title = "Medical History: status",
		labelVars = labelVarsADaMPelican
	)
	# exposure
	exPlotsADaM <- subjectProfileIntervalPlot(
		data = ADaMDataPelican$ADEX,
		paramVar = c("EXTRT", "EXDOSE", "EXDOSU"),
		timeStartVar = "EXSTDY",
		timeEndVar = "EXENDY",
		colorVar = "EXDOSFRM",
		labelVars = labelVarsADaMPelican,
		title = "Treatment exposure"
	)
	# adverse events
	aePlotsADaM <- subjectProfileIntervalPlot(
		data = ADaMDataPelican$ADAE,
		paramVar = "AETERM",
		timeStartVar = "ASTDY",
		timeEndVar = "AENDY",
		colorVar = "AESEV",
		labelVars = labelVarsADaMPelican,
		title = "Adverse events"
	)
	# laboratory
	adlb <- ADaMDataPelican$ADLB
	adlb$ANRIND <- factor(with(adlb, reorder(ifelse(ANRIND == "", NA, ANRIND), ANRINDN)), exclude = NULL)
	lbPlotsADaM <- subjectProfileEventPlot(
		data = adlb,
		paramVar = "PARAM",
		paramGroupVar = c("PARCAT1", "PARCAT2"),
		timeVar = "ADY",
		colorVar = "ANRIND",
		labelVars = labelVarsADaMPelican,
		shapeVar = "ANRIND",
		title = "Laboratory test measurements",
		shapePalette = c('L' = 25, 'N' = 19, 'H' = 24, 'NA' = 3)
	)

	# create report
	listPlotsADaM <- list(slPlotsADaM, mhPlotsADaM, exPlotsADaM, aePlotsADaM, lbPlotsADaM)
	pathReport <- "subjectProfile_ADAM.pdf"
	system.time(createSubjectProfileReport(
		listPlotsADaM,
		refLines = refLinesParam,
		outputFile = pathReport,
		subjectSubset = "study-4902-02"
	))
	include_graphics(pathReport)

```

# Optimization of patient profiles creation

For big clinical trial, the creation of the subject profile report can be time-consuming.

Please find below a few advices:

* during the development of the patient profiles for 
a specific study, the different modules can be created only for a
**subset of the subjects** via the `subjectSubset` or `subsetData`/`subsetVar`/`subsetValue`
parameters
* for the final creation of the  patient profiles on the entire set of patients:
    + the reports can be exported **by batch of X subjects**, via the `exportBatchSize`
    parameter. Exporting the patient profiles by batch of 10 subjects can be a good idea for a
    for study with a high number of patients.
    + the report can be parallelized by specifying a number of cores > 1 to the parameter **`nCores`**
of the `createSubjectProfileReport` function. In this case,
the **package `parallel` is required**. To check the number of cores available
in your system, you may use: `parallel::detectCores()`.

# Appendix

## Session information

```{r includeSessionInfo, echo = FALSE}

	pander(sessionInfo())

```
